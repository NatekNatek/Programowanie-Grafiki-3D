# Debugging and handling errors

Debugging OpenGL code can be a frustrating experience.
The OpenGL API is a very low level, and it is easy to make mistakes.
The errors are for most of the part not reported by the API, and you have to check for them manually.

This document will provide you with an example of how to handle errors in OpenGL code.
The code of this example is provided in the `src/Assignments/Debug` directory.
I have rigged the example to generate an error, so you can see how the error is reported.

The error is introduced in the third line of the following code taken from
`src/Assignments/Debug/app.cpp`:

```c++
GLuint v_buffer_handle;
OGL_CALL(glCreateBuffers(1, &v_buffer_handle));
v_buffer_handle++;
OGL_CALL(glNamedBufferData(v_buffer_handle, vertices.size() * sizeof(GLfloat), vertices.data(),
    GL_STATIC_DRAW));
```

I have increased the value of the `v_buffer_handle` variable by one
and as a results it does not contain any existing buffer name.
That will cause the error in the following `glNamedBufferData` function call.
Without any error checking, the program would just produce an empty window.
Because of the OGL_CALL macros, the error will be reported and the program will abort as described below.

## Catching errors

Each call to the OpenGL API can result in an error.
The error is reported by setting an error flag.
The error flag can
be read using the `glGetError` function. The function returns the error flag and clears it. If the error flag is set,
the function returns the error code. If the error flag is not set, the function returns `GL_NO_ERROR`.

Currently, the error flag can be set to one of the following values:
`GL_INVALID_ENUM`, `GL_INVALID_VALUE`, `GL_INVALID_OPERATION`, `GL_INVALID_FRAMEBUFFER_OPERATION`, `GL_OUT_OF_MEMORY`,
`GL_STACK_UNDERFLOW`, `GL_STACK_OVERFLOW`.

Unfortunately, those are just symbolic constants, and they are not very helpful. I have provided a function that will
translate the error code to a string. The function is called `error_msg`and is defined in `Application/utils.h` file.
The function takes the error code as an argument and returns the string describing the error.

The typical usage of this function is as follows:

```c++
glBindBuffer(GL_ARRAY_BUFFER, v_buffer_handle + 1);
    auto error_code = glGetError();
    if (error_code != GL_NO_ERROR) {
        std::cerr << "Error: " << xe::utils::error_msg(error_code) << "  at " << __FILE__ << ":" << (__LINE__ - 3)
                  << std::endl;
    }
```

Macros `__FILE__` and `__LINE__` are replaced by the preprocessor with the current file name and line number. We need to
subtract three from line number as the error was generated in the line with the `glNamedBufferData` call.
This results in the following error message:

```text
Error: INVALID OPERATION  glNamedBufferData(v_buffer_handle, vertices.size() * sizeof(GLfloat), vertices.data(),GL_STATIC_DRAW) 
/home/pbialas/Dydaktyka/Graphics3D/Teaching/Graphics3DCode/src/Assignments/Debugging/app.cpp:53
``` 

Each function in the OpenGL API has a description of the possible errors that can be generated by the function.
If you type the name of the function  into a serach engine it will most probably lead you to the [OpenGLÂ® 4.5 Reference Pages](https://www.khronos.org/registry/OpenGL-Refpages/gl4/) for this function.
For [`glNamedBufferData`](https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBufferData.xhtml) function the
description is as follows:

```text
Errors
GL_INVALID_ENUM is generated by glBufferData if target is not one of the accepted buffer targets.
GL_INVALID_ENUM is generated if usage is not GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, 
        GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.
GL_INVALID_VALUE is generated if size is negative.
GL_INVALID_OPERATION is generated by glBufferData if the reserved buffer object name 0 is bound to target.
GL_INVALID_OPERATION is generated by glNamedBufferData if buffer is not the name of an existing buffer object.
GL_INVALID_OPERATION is generated if the GL_BUFFER_IMMUTABLE_STORAGE flag of the buffer object is GL_TRUE.
GL_OUT_OF_MEMORY is generated if the GL is unable to create a data store with the specified size.
```

This description together with the error message should help you find the source of the error.

The only way to reset the error flag is by the call to the `glGetError` function, so if you check for errors on after
several calls
to OpenGL API, you will not know which call generated the error. If more than one call generated an error, you will only
get the error code of the first call. So error checking should be done after __each__ call to the OpenGL API.
This is very tedious and error-prone. To make this easier, I have provided a `OGL_CALL` macro that will check for errors
after each call if you wrap each OpenGL function call with this macro. The macro is defined in `src/Application/utils.h` and
is used as follows:

```c++
OGL_CALL(glNamedBufferData(GL_ARRAY_BUFFER, v_buffer_handle));
```
resulting in the following output:
```text
2024-10-07 16:02:27.784] [critical] OpenGL error: INVALID OPERATION  glNamedBufferData(v_buffer_handle, vertices.size() * sizeof(GLfloat), vertices.data(), GL_STATIC_DRAW) 
   /home/pbialas/Dydaktyka/Graphics3D/Teaching/Graphics3DCode/src/Assignments/Debugging/app.cpp:53
```

This macro will abort the program if the error is generated, forcing you to fix the error.
This behavior can be changed by defining the macro

```c++
#define DEBUG_NO_ABORT
```

at the top of the file. In this case, the macro will only print the error message and continue execution.

I __strongly__ recommend using the `OGL_CALL` macro. It will save you a lot of time and frustration. As pointed out
before this macro has to be used consistently. If you forget to wrap a function call with this macro, you may get the
wrong error or not detect an error at all.

## Debug output

Since the OpenGL version 4.3 there is another mechanism for error reporting.
It is called the debug output.
If configured properly, OpenGL will generate messages that can be used for debugging.
Those messages can be received
using a callback function, which is registered using the `glDebugMessageCallback` function.
I have configured the OpenGL context
as to provide the debug messages and registered a callback function that will log the error messages.
As you can see from the output below

```c++
---------------
Debug message (1282): GL_INVALID_OPERATION error generated. <buffer> does not refer to an existing buffer object.
Source: API
Type: Error
Severity: high
```

this function provides more information than the `glGetError` function,
but does not provide the line number and file name where the error was generated.
It has, however, the advantage of being called consistently at each OpenGL call.
This is maybe an overkill, but I propose to use both methods for error checking.


## Debugging shaders

Another aspect of the OpenGL API is that it is that part of the code is executed on another device (GPU). OpenGL API
does not provide any tools for debugging the code running on the GPU. 

TBD


